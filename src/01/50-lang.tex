% !TEX root = 01.tex

\section{LLVM-IR language}


\begin{frame}{LLVM IR}
The LLVM IR~\cite{LOCAL:www/llvmLanguageRef} language is RISC-based:

\begin{itemize}
\item instructions operates on \alert{variables}
\begin{itemize}
\item aka virtual registers, temporary values
\end{itemize}
\item only \llvminline{load} and \llvminline{store} access memory
\item \llvminline{alloca} used to reserve memory on the stack
\end{itemize}
\vfill
There are also a few \alert{high level instructions}:
\begin{itemize}
\item function call -- \llvminline{call}
\item pointer arithmetics -- \llvminline{getelementptr}
\item \ldots
\end{itemize}
\end{frame}


\begin{frame}{LLVM IR}{Types \& Variables}
LLVM IR is \alert{strongly typed}:

\begin{itemize}
\item e.g. you cannot assign a floating point value to an integer variable
without an explicit cast
\end{itemize}

\alert{Almost everything} is \alert{typed}:\\
\smallskip
\begin{tabular}{>{\RaggedLeft\arraybackslash}p{5.5em}lcl}
\textbf{functions} & \llvminline{@fact} & $\rightarrow$ & \llvminline{i32 (i32)} \\
\textbf{statements} & \llvminline{\%3 = icmp eq i32 \%2, 0} & $\rightarrow$ & \llvminline{i1}
\end{tabular}\\
\smallskip
A variable can be:\\
\smallskip
\begin{tabular}{>{\RaggedLeft\arraybackslash}p{5.5em}l}
\textbf{global} & \llvminline{@var = common global i32 0, align 4} \\
\textbf{argument} & \llvminline{define i32 @fact(i32 \%n)} \\
\textbf{local} & \llvminline{\%2 = load i32, i32* \%1, align 4} \\
\end{tabular}\\
\bigskip
Local variables are defined by statements
\end{frame}


\begin{frame}{LLVM IR}{Example: factorial}
\begin{center}
\begin{varwidth}{20cm}
\llvminput[\ttfamily\fontsize{7pt}{5pt}\selectfont]{snippet/fact.ll}
\end{varwidth}
\end{center}
\end{frame}


\begin{frame}{LLVM IR Language}{Static Single Assignment}
LLVM IR is SSA-based:

\begin{itemize}
\item every variable is \alert{statically assigned} exactly \alert{once}
\end{itemize}
\bigskip
Statically means that:

\begin{itemize}
\item inside each function...
\item ...for each variable \llvminline{\%foo}...
\item ...there is \alert{only one} statement in the form \llvminline{\%foo = ...}
\end{itemize}
\bigskip
\alert{Static} (compile time) $\neq$ \alert{dynamic} (runtime)
{\footnotesize
\begin{itemize}
\item Single \emph{Dynamic} Assignment:\\\emph{in the execution trace} there is only one assignment to a variable \texttt{x}
\item Single \emph{Static} Assignment:\\\emph{in the code listing} there is only one assignment to a variable \texttt{x}
\begin{itemize}
\scriptsize
\item Assignments \alert{can} be performed multiple times (in a loop for example)
\end{itemize}
\end{itemize}
}
\end{frame}


\begin{frame}{Static Single Assignment}{Examples}
\begin{block}{Scalar SAXPY}
\cinput[\ttfamily\small]{snippet/scalar-saxpy.c}
\end{block}

\begin{block}{Scalar LLVM SAXPY}
\llvminput[\ttfamily\small]{snippet/scalar-saxpy.ll}
\end{block}

Temporary \llvminline{\%1} not reused! \llvminline{\%2} is used for the second
assignment!
\end{frame}


\begin{frame}{Static Single Assignment}{Examples}
\begin{block}{Array SAXPY}
\cinput[\ttfamily\scriptsize]{snippet/array-saxpy.c}
\end{block}

\begin{block}{Array LLVM SAXPY}
\llvminput[\ttfamily\scriptsize]{snippet/array-saxpy.ll}
\end{block}

One assignment for loop counter \llvminline{\%i.0}
\end{frame}

\begin{frame}{Static Single Assignment}{Handling Multiple Assignments}
\begin{block}{Max}
\cinput[\ttfamily\scriptsize]{snippet/max.c}
\end{block}

\begin{block}{LLVM Max -- WRONG}
\llvminput[\ttfamily\scriptsize]{snippet/bad-max.ll}
\end{block}

Why is it \alert{wrong}?
\end{frame}


\begin{frame}{Static Single Assignment}{Use \llvminline{phi} to Avoid Troubles}
The \llvminline{\%2} variable must be statically assigned once!

\begin{block}{LLVM Max}
\llvminput[\ttfamily\footnotesize]{snippet/good-max.ll}
\end{block}

The \llvminline{phi} instruction is a \emph{conditional move}:

\begin{itemize}
\item it takes $(\textrm{variable}_i, \textrm{label}_i)$ pairs
\item if coming from predecessor identified by $\textrm{label}_i$, its value is $\textrm{variable}_i$
\end{itemize}
\end{frame}


\begin{frame}{Static Single Assignment}{Definition and Uses}
Each SSA variable is assigned only once:

\begin{itemize}
\item variable \alert{definition}
\end{itemize}

\vfill
Each SSA variable can be referenced by multiple instructions:

\begin{itemize}
\item variable \alert{uses}
\end{itemize}

\vfill
Algorithms and technical language abuse of these terms!

\vfill
\emph{
Let \llvminline{\%foo} be a variable. If the definition of \llvminline{\%foo} does not
have side-effects nor uses, the aforementioned \llvminline{\%foo} variable 
can be erased from the CFG without altering program semantics.
}
\end{frame}


\begin{frame}{Static Single Assignment}{Rationale}
Old compilers are not SSA-based:

\begin{itemize}
\item converting non-SSA input into SSA form is expensive
\item cost must be amortized
\end{itemize}

\vfill
New compilers are SSA-based:

\begin{itemize}
\item SSA easier to work with
\item SSA-based analysis/optimizations are faster
\end{itemize}

\vfill
%All modern compilers are SSA-based:
%
%\begin{itemize}
%\item exception are old version of the HotSpot Client compiler
%\end{itemize}
\end{frame}
